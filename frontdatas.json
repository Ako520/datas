[
  { "_id" :"580863b23c1a752c5fb3f8e8", "title" : "今天玩啥捏---利用canvas做的随机小游戏", "subtitle" : "自从HTML5画布(Canvas)功能面世后，各种利用canvas和JavaScript的酷炫动画效果就层出不穷。那么绚丽的页面效果以及游戏动画效果的原理是怎样的?<br /><br />游戏地址 : https://ako520.github.io/randomselect/","createTime" : "2016-10-20T06:26:58.224Z", "__v" : 0 },
  { "_id" :"5809a58ec0d05e0fda8028bc", "title" : "显示在react的jsx中无法正常显示的代码(例如换行等)", "subtitle" : "昨天在弄自己的博客时候,遇到一个问题。从服务器获取的数据中存在&ltbr />---也就是换行，但是!数据并没有换行而是直接显示出来了。怒！这和我想要的效果不一样啊(╯‵□′)╯︵┻━┻","content" : "## 显示在react的jsx中无法正常显示的代码(例如换行等)\n昨天在弄自己的博客时候,遇到一个问题。从服务器获取的数据中存在`<br/>`---也就是换行，但是!数据并没有**换行**而是直接显示出来了。怒！这和我想要的效果不一样啊(╯‵□′)╯︵┻━┻\n\n```javascript\nlet content=\"我要换行<br />我要换行\"\n//jsx语法\nrender () {\n  return(\n    <div>\n      {content}  \n    </div>\n  )\n}\n```\n将代码放在react中页面显示的是\n\n![让我换行1](http://odp3ysykq.bkt.clouddn.com/%E6%98%BE%E7%A4%BA%E5%9C%A8react%E7%9A%84jsx%E4%B8%AD%E6%97%A0%E6%B3%95%E6%AD%A3%E5%B8%B8%E6%98%BE%E7%A4%BA%E7%9A%84%E4%BB%A3%E7%A0%811.png)\n\n我们想让代码在页面中显示的样子是\n\n![让我换行2](http://odp3ysykq.bkt.clouddn.com/%E6%98%BE%E7%A4%BA%E5%9C%A8react%E7%9A%84jsx%E4%B8%AD%E6%97%A0%E6%B3%95%E6%AD%A3%E5%B8%B8%E6%98%BE%E7%A4%BA%E7%9A%84%E4%BB%A3%E7%A0%812.png)\n\n\n要想解决这种问题就要这样改一下代码\n```javascript\nlet content=\"我要换行<br />我要换行\"\n//jsx语法\nrender () {\n  return(\n    <div dangerouslySetInnerHTML={{__html:content}}>\n    </div>\n  )\n}\n```\n官方文档介绍了[Dangerously Set innerHTML](https://facebook.github.io/react/tips/dangerously-set-inner-html.html),\n然而看完并没懂啊,这是因为我们不清楚什么是**cross-site scripting (XSS)**攻击\n\n了解更多可以参考[cross-site scripting (XSS)攻击简介](http://www.cnblogs.com/loveis715/archive/2012/07/13/2506846.html)\n\nreact之所以不直接读取你的html代码，是为了避免安全问题，如果有人提交了有攻击性的代码到你的数据库里(例如评论)，当数据库读出来数据显示到页面的时候，所有浏览了这个页面的人都可能会被盗取重要的信息。", "createTime":"2016-10-21T05:20:14.651Z", "__v" : 0 },
  {
    "_id" : "58173c547f075651bf73d090", "title" : "使用sass来做断点", "subtitle" : "如果你之前在做响应式设计的话，那么你会知道处理几种不同的媒体查询会很麻烦。现在有一个好的做法：用变量把不同的断点值存储起来。每次使用的时候只需要用对应的变量就行了。", "content" : "## 使用sass来做断点\n\n最下面有用法的总结\n\n如果你之前在做响应式设计的话，那么你会知道处理几种不同的媒体查询会很麻烦。现在有一个好的做法：用变量把不同的断点值存储起来。每次使用的时候只需要用对应的变量就行了。\n\n#### 可以直接用来套用的sass断点模板\n\n如果想更进一步的话，你可以去命名每个断点。这样的话，断点处理mixin就只根据这个断点名字就可以输出对应的断点查询。\n\n还可以再进行优化，那就是把 这些命名和它对应的断点 存储在一个map中。代码如下：\n```javascript\n$breakpoints: (\n  'tiny':   ( max-width:  767px ),\n  'small':  ( min-width:  768px ),\n  'medium': ( min-width:  992px ),\n  'large':  ( min-width: 1200px ),\n  'custom': ( min-height:  40em )\n);\n$width: (\n  'tiny'  : 200px,\n  'small'  : 300px,\n  'medium' : 400px,\n  'large' : 500px,\n);\n@mixin breakpoint($name) {\n  @if map-has-key($breakpoints, $name) {\n    @media #{inspect(map-get($breakpoints, $name))} {\n\n    //以下代码表示每次改变media大小.element的width改变并且他的子元素的宽度也随之改变\n\n      //类型1 这里写公有部分 每次随着media改变都会改变的样式\n      .element{\n        width:map-get($width,$name);\n\n        //类型2 每次随着media改变都会改变 并且 和其他变量有某种联系\n        .childElement{\n\n          width:map-get($width,$name)/2;\n\n          background:yellow; //会被正常写的样式覆盖掉 这里需要注意\n        }\n\n    }\n\n\n    @content;  //`@content`用在`mixin`里面的，当定义一个`mixin`后，并且设置了`@content`；\n              //在`@include`引用的时候可以传入相应的内容到`mixin`里面\n    }\n  }\n  @else {\n    @warn \"Couldn't find a breakpoint named `#{$name}`.\";\n  }\n}\n```\n\n如果 breakpoint mixin中传入的字符串值和 $breakpoints 这个map中的某个键值匹配，那么这个mixin会打开一个@media指令，然后使用 inspect 函数（来自Sass 3.3）输出这个map。当使用 inspect((key:value)) 时，`(key:value)`这个字符串会被输出到样式表中，相当于字符串化操作。\n\n如果传入的字符串参数没有匹配任何一个断点map的键值，那么 @warn 这个指令会输出警告信息，在控制台里可以看到。\n\n#### 用法实例\nsass:\n```javascript\nSass：\n\n.element {\n\n  color: red;  \n\n  @include breakpoint(tiny) {\n\n  }\n  @include breakpoint(small) {\n\n  }\n  @include breakpoint(medium) {\n\n    color: blue;   //类型3 这里写上私有部分一般也不和其他元素有关联\n  }\n  @include breakpoint(large) {\n\n  }\n}\n\n```\n\nCSS 输出：\n```javascript\n.element {\n\n  color: red;   \n  .childElement{\n    background:black;  //会覆盖掉media query中的样式\n  }\n  @media (max-width: 767px) {\n    width:200px;\n    .childElement{\n      width:100px;\n    }\n  }\n  @media (min-width: 768px) {\n    width:300px;\n    .childElement{\n      width:150px;\n    }\n  }\n  @media (min-width: 992px) {\n    width:400px;\n    .childElement{\n      width:200px;\n    }\n    .element {\n      color: blue;\n    }\n  }\n  @media (min-width: 992px) {\n    width:500px;\n    .childElement{\n      width:250px;\n    }\n  }\n}\n\n```\n\n根据不同需求到不同的位置写上代码才会事半功倍，下面分为三种类型\n1. 每次改变media都会跟着改变的样式\n2. 每次随着media改变都会改变 并且 和其他变量有某种联系\n3. 只有在某个特定的media时才会改变的样式\n","createTime":"2016-10-31T12:43:00.413Z", "__v" : "0"
  },
  {
    "_id" : "58173df67f075651bf73d091", "title" : "在react开发环境中安装sass", "subtitle" : "css是一件很麻烦的东西.它没有变量，也没有条件语句，只是一行行单纯的描述，写起来相当费事。而sass会让你css变得简单可控。下面来介绍怎么在react开发环境中安装sass", "content" : "## 在react中安装sass\n\ncss是一件很麻烦的东西.它没有变量，也没有条件语句，只是一行行单纯的描述，写起来相当费事。而sass会让你css变得简单可控。下面来介绍怎么在react开发环境中安装sass\n\n#### 安装SASS\n打开命令行并输入\n```javascript\n$ npm i sass-loader sourceMap -D\n```\n#### SASS Loader 和 sourceMap特性\n为了能让我们的webpack在打包的时候可以正确解析到jsx格式的文件，我们需要加入bable这个loader的支持。同样，这里我们为了让webpack在打包时能正确解析到scss，我们也需要加上相应的loaders。\n\n我们打开webpack.config.js，在loaders代码块里面加入以下代码:\n```javascript\ntest: /\\.scss$/,\nloaders: [\"style\", \"css?sourceMap\", \"sass?sourceMap\"]\n}\n```\n\n需要主义的是：如果存在两个webpack环境(测试环境dev和生产环境prod)则需要分别都加入上面代码\n\nloader的作用上面已经解释过了,而sourceMap这里主要的目的就是方便我们调试sass代码。因为sass代码最终还是要编译成css的，而我们在调试的时候，我们更愿意在Chrome的开发者工具中能够直接看到我们的sass代码来进行调试。使用sourceMap才能在F12开发者工具中看到正确的css代码\n\n关于sass的语法推荐看一下阮一峰的[SASS用法指南](http://www.ruanyifeng.com/blog/2012/06/sass.html)", "createTime" : "2016-10-31T12:49:58.327Z", "__v" : "0"
},{ "_id" : "582417e390be020773bf9672", "title" : "路由嵌套和动态判断---解决react-router的activeClassName", "subtitle" : "用了两天时间终于把困扰我的react-router问题解决了，加油~\\(≧▽≦)/~", "content" : "## 路由嵌套和动态判断---解决react-router的activeClassName\n用了两天时间终于把困扰我的react-router问题解决了，加油~\\(≧▽≦)/~\n#### 问题描述\n在说路由嵌套和动态判断之前，先说说我遇到了什么问题\n\n1. 我希望导航一直显示\n2. 导航中的选项被点击会有样式来提醒用户被选中\n  ```javascript\n  // nav\n  <Link to=\"/frontblog\" activeClassName='activeRoute'>前端开发</Link>\n  <Link to=\"/backblog\" activeClassName='activeRoute'>后端开发</Link>\n  <Link to=\"/bloghistory\" activeClassName='activeRoute'>博客更新</Link>\n\n  // css\n  .activeRoute{\n      border-left: 5px solid #70a3ff;\n  }\n  ```\n3. 前端开发 ( /frontblog ) 是个文章列表，点进去可以看到文章具体页 ( /frontblog/id ) 即使我在前端文章具体页，导航对应的前端开发仍然应该有被选中的样式activeClassName\n\n目前我的路由配置是这个样子的\n```javascript\n<Router history={browserHistory}>\n  <Route path=\"/\" component={App}>\n    <Route path=\"bloghistory\" component={BlogHistory}/>\n\n    <Route  path=\"frontblog\" component={FrontBlog}/>\n    <Route path=\"frontblog/:id\" component={Article}/>\n\n    <Route path=\"backblog\" component={BackBlog}/>\n    <Route path=\"backblog/:id\" component={Article}/>\n\n    <Route path='404' component={NotFoundPage}/>\n    <Redirect from='*' to='/404' />\n  </Route>\n</Router>\n```\n如果我现在处于 /frontblog那么activeClassName的样式就会生效，但如果在/frontblog/12345 就会失效\n\n由于 **/frontblog/12345** 是一条单独的路由，而`<Link to=\"/frontblog\" activeClassName='activeRoute'>前端开发</Link>`是要在**/frontblog**\n\n解决问题的灵感来源于推酷上的[再谈 React Router 使用方法](http://www.tuicool.com/articles/RzYjMju)虽然是一篇比较\"老\"的文章，不过真心感谢前辈提供思路\n\n#### 解决方法\n办法有两种**路由嵌套**和**动态判断**\n\n路由嵌套的思路是既然只有/frontblog可以触发activeClassName那我把/frontblog/12345变成/frontblog的子路由(路由嵌套)就可以了，但是路由嵌套会让文章列表也显示在页面中\n```javascript\n//路由配置\n<Router history={browserHistory}>\n  <Route path=\"/\" component={App}>\n    <Route path=\"bloghistory\" component={BlogHistory}/>\n\n    <Route  path=\"frontblog\" component={FrontBlog}>\n      <Route path=\":id\" component={Article}/>\n    </Route>\n\n    <Route path=\"backblog\" component={BackBlog}>\n      <Route path=\":id\" component={Article}/>\n    </Route>\n\n    <Route path='404' component={NotFoundPage}/>\n    {/* 其他重定向到 404 */}\n    <Redirect from='*' to='/404' />\n  </Route>\n</Router>\n\n//Frontblog.js\n<div>\n  <div>文章1</div>  \n  <div>文章2</div>  \n  <div>文章3</div>  \n  {this.props.children}\n</div>\n```\n\n动态判断的思路是\n> 取消了嵌套在列表路由下的详情页路由，同时改造了列表页路由的 path，从原来的 /frontblog 改为 /frontblog/:id? 。这样的 path 代表着这条路由匹配所有 /frontblog/ 开头的 URL，同时可能存在一个 id 参数，也可能不存在。\n\n使用动态判断的方法让文章列表不再显示\n```javascript\n<Router history={browserHistory}>\n  <Route path=\"/\" component={App}>\n    <Route path=\"bloghistory\" component={BlogHistory}/>\n\n    <Route  path=\"frontblog/:id?\" component={FrontBlog}/>\n\n    <Route path=\"backblog/:id?\" component={BackBlog}/>\n\n    <Route path='404' component={NotFoundPage}/>\n    {/* 其他重定向到 404 */}\n    <Redirect from='*' to='/404' />\n  </Route>\n</Router>\n\n//FrontBlog.js\n<div>\n  {/* isEmpty是lodash中的一个方法用来验证传入的变量是否有值 如果为空会返回true 不为空返回false */}\n  {isEmpty(this.props.params.url) ? (\n    <div>文章1</div>  \n    <div>文章2</div>  \n    <div>文章3</div>\n  ) : {this.props.children}\n  }\n</div>\n```\n\n#### 后续\n目前我使用的方法是结合二者，在路由嵌套中使用动态判断的方法，这个就留待小伙伴们自己开发了\n\n这样就把之前挖下的坑总算是松了土，可喜可贺(得意)\n", "createTime" : ISODate("2016-11-10T06:46:59.187Z"), "__v" : 0 }


]
